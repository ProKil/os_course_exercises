#lec 3 SPOC Discussion

##**提前准备**
（请在上课前完成）


 - 完成lec3的视频学习和提交对应的在线练习
 - git pull ucore_os_lab, v9_cpu, os_course_spoc_exercises  　in github repos。这样可以在本机上完成课堂练习。
 - 仔细观察自己使用的计算机的启动过程和linux/ucore操作系统运行后的情况。搜索“80386　开机　启动”
 - 了解控制流，异常控制流，函数调用,中断，异常(故障)，系统调用（陷阱）,切换，用户态（用户模式），内核态（内核模式）等基本概念。思考一下这些基本概念在linux, ucore, v9-cpu中的os*.c中是如何具体体现的。
 - 思考为什么操作系统需要处理中断，异常，系统调用。这些是必须要有的吗？有哪些好处？有哪些不好的地方？
 - 了解在PC机上有啥中断和异常。搜索“80386　中断　异常”
 - 安装好ucore实验环境，能够编译运行lab8的answer
 - 了解Linux和ucore有哪些系统调用。搜索“linux 系统调用", 搜索lab8中的syscall关键字相关内容。在linux下执行命令: ```man syscalls```
 - 会使用linux中的命令:objdump，nm，file, strace，man, 了解这些命令的用途。
 - 了解如何OS是如何实现中断，异常，或系统调用的。会使用v9-cpu的dis,xc, xem命令（包括启动参数），分析v9-cpu中的os0.c, os2.c，了解与异常，中断，系统调用相关的os设计实现。阅读v9-cpu中的cpu.md文档，了解汇编指令的类型和含义等，了解v9-cpu的细节。
 - 在piazza上就lec3学习中不理解问题进行提问。

## 第三讲 启动、中断、异常和系统调用-思考题

## 3.1 BIOS
-  BIOS从磁盘读入的第一个扇区是是什么内容？为什么没有直接读入操作系统内核映像？

主引导记录MBR和硬盘分区表DPT。因为并不知道该从哪个分区启动哪个操作系统
  
- 比较UEFI和BIOS的区别。

1. UEFI启动需要一个独立的分区将系统启动文件和操作系统本身隔离；2. 传统的BIOS启动由于MBR的限制，默认是无法引导超过2TB以上的硬盘的，而UEFI可以；3. UEFI启动时可以加载指定启动文件。
 
- 描述PXE的大致启动流程。

   - 客户端电脑开机后，BIOS设置从网络启动
   - 网卡中的PXE Boot ROM自测，获得控制权，然后发送一个动态获得IP地址的广播包。
   - DHCP服务器在收到该广播包后，发送给客户端分配IP地址的DHCP回应包。内容包括客户端的IP地址，TFTP服务器的IP地址（DHCP服务器的066选项），预设通讯通道，及开机启动文件（DHCP服务器的067选项）。该文件应该是一种由PXE启动规范规定的固定格式的可执行文件，类似于Windows XP正常启动时显示多重启动菜单之前的启动代码。 
   - 客户面收到DHCP回应后，则会响应一个FRAME，以请求传送启动文件。之后，服务端将和客户机再进行一系列应答，决定启动参数。
   - 客户端通过TFTP通讯协议从服务器下载开机启动文件。启动文件接收完成后，将控制权转交给启动块，完成PXE启动。客户端通过这个开机影像文件开机，这个开机文件可以只是单纯的开机程式也可以是操作系统。

## 3.2 系统启动流程

- 分区引导扇区的结束标志是什么？0X55AA
- 如何指定内核加载的参数？加载程序的启动菜单
- BIOS、BIOS-MBR、BIOS-GPT的区别是什么？只支持一个分区、支持4个启动分区、支持更多启动分区
- 在UEFI中的可信启动有什么作用？通过启动前的数字签名检查来保证启动介质的安全性
- 了解NTLDR的启动流程。
 
1. 访问启动磁盘的文件系统
2. 如果Windows在休眠，hiberfil.sys会被载入内存，系统会在休眠的地方继续
3. 其他情况，读取boot.ini，然后给用户看启动菜单
3. 如果选择了非NT架构的OS，NTLDR载入boot.ini所列相关文件，然后移交控制权
4. 如果选择了NT架构的OS，NTLDR运行ntdetect.com

 
-  了解GRUB的启动流程。


   - BIOS加载MBR里面的GRUB，由于只有GRUB只占用446字节所以不能实现太多的功能，所以就有此阶段里面的文件来加载下一阶段的文件（/boot/grub下的文件）
   - 加载识别文件系统的程序，来识别文件系统，不加载就无法识别文件系统，进而就找不到boot目录，由于GRUB是无法识别LVM，所以不能把/boot分区设置为LVM，所以必须要把/boot单独分区
   - 开始寻找内核，启动内核

 
 
- 比较NTLDR和GRUB的功能有差异。
 
ntldr只能引导win，只能装在硬盘；而grub能引导多种操作系统，还能从多种设备上引导

 
- 了解u-boot的功能。

 u-boot 是一个主要用于嵌入式系统的引导程序，可以支持多种不同的计算机系统结构，包括 PPC、ARM、AVR32、MIPS、x86、68k、Nios 与 MicroBlaz,有丰富的设备驱动源码，如串口、以太网、SDRAM、FLASH、LCD、NVRAM、EEPROM、RTC、键盘等。u-boot不仅仅支持嵌入式Linux系统的引导，它还支持NetBSD, VxWorks, QNX, RTEMS, ARTOS, LynxOS, android嵌入式操作系统。



## 3.3 中断、异常和系统调用比较
- 什么是中断、异常和系统调用？
   1. 中断：外部意外的响应；
   1. 异常：指令执行意外的响应；
   1. 系统调用：系统调用指令的响应；
-  中断、异常和系统调用的处理流程有什么异同？
   发生中断时系统会直接进入中断处理流程，保存现场。异常则会等待这一条指令结束后处理异常，之后返回这一条或下一条指令。系统调用会进入内核态。
   
- 如何理解系统调用的同步和异步响应？

  同步响应：有些系统调用要等系统服务完成后才返回；异步响应：有些系统调用在系统服务没完成就返回了；
      
- 系统调用表的内容是什么？
  系统调用的功能编号和入口地址
  
- Linux的系统调用有哪些？大致的功能分类有哪些？

Linux的系统调用大概有250个左右，其继承了UNIX系统调用中最基本和最有用的部分，按照功能逻辑大致可以分为如下几类：

1. 进程控制：创建、终止、挂起进程等基本操作以及进程信息的查询
2. 文件系统控制：打开、关闭、读写文件等基本操作以及更改文件属性等系统操作
3. 系统控制：系统内核相关信息的查询以及一些系统级别的控制操作
4. 内存管理：分配、释放内存、地址映射、缓冲写回等内存相关的操作
5. 网络管理：域名的查询和设置以及主机名称、标识号的查询与设置
6. socket控制：建立连接、发送消息、断开连接等一系列套接字操作
7. 用户管理：用户和组相关信息的设置和查询
8. 进程间通信：进程间的消息、信号、管道、共享内存等通信操作

- 以ucore lab8的answer为例，uCore的系统调用有哪些？大致的功能分类有哪些？

ucore lab8的answer中共有22个系统调用，大致分为如下几类

1. 进程管理：包括 fork/exit/wait/exec/yield/kill/getpid/sleep
2. 文件操作：包括 open/close/read/write/seek/fstat/fsync/getcwd/getdirentry/dup
3. 内存管理：pgdir命令
4. 外设输出：putc命令


 
## 3.4 linux系统调用分析
-  通过分析[lab1_ex0](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex0.md)了解Linux应用的系统调用编写和含义。
 
objdump的作用是将一个文件反汇编得到其各个程序段的汇编码，以该文件为例，使用-S参数后得到代码段.text的全部反汇编内容；

nm的作用是显示特定文件的符号信息，该程序的符号信息输出包括 _start 的地址 0x080482f0 ， SYS_write 的值 0x04 等等

file的作用是显示指定文件的格式，该文件输出结果为：ELF格式32位小端序可执行文件，Intel 80386架构，动态链接等

Linux系统调用主要是通过 int 0x80 实现，通过寄存器 eax , ebx , ecx , edx 传入参数来，其中 eax 代表系统调用号，而 ebx 往后均为系统调用函数的参数

 
- 通过调试[lab1_ex1](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex1.md)了解Linux应用的系统调用执行过程。


strace可以跟踪进程执行时的系统调用和所接收的信号，加上-c参数后还可以知道每个调用所花费的时间。

- 通过 Bash，调用 execve 通知操作系统执行程序
- 调用 brk(0)，开始建立程序栈基址
- 调用 access，访问一些动态链接库
- 调用 open，read 和 close，读入文件
- 通过 arch_prctl 设定程序运行架构
- 使用 mprotect 设置内存保护属性
- 调用 write，将 Hello World 输出
- exit_group 退出程序
- 期间有多次调用 mmap，进行内存虚实转化


 
